[
  {
    "id": "two-sum",
    "title": "Two Sum",
    "category": "Array",
    "difficulty": "Easy",
    "description": "Find indices of two numbers that add up to target.",
    "initialData": [
      2,
      7,
      11,
      15
    ],
    "visualType": "ARRAY",
    "complexity": {
      "time": "O(N)",
      "space": "O(N)"
    },
    "example": {
      "input": "nums = [2, 7, 11, 15], target = 9",
      "output": "[0, 1]"
    },
    "code": {
      "javascript": "function twoSum(nums, target) {\n  const map = new Map();\n  for (let i = 0; i < nums.length; i++) {\n    const complement = target - nums[i];\n    if (map.has(complement)) return [map.get(complement), i];\n    map.set(nums[i], i);\n  }\n}",
      "python": "def two_sum(nums, target):\n    prevMap = {}\n    for i, n in enumerate(nums):\n        diff = target - n\n        if diff in prevMap: return [prevMap[diff], i]\n        prevMap[n] = i"
    }
  },
  {
    "id": "best-time-to-buy-and-sell-stock",
    "title": "Best Time to Buy and Sell Stock",
    "category": "Array",
    "difficulty": "Easy",
    "description": "Find max profit from a single buy/sell operation.",
    "initialData": [
      7,
      1,
      5,
      3,
      6,
      4
    ],
    "visualType": "ARRAY",
    "complexity": {
      "time": "O(N)",
      "space": "O(1)"
    },
    "example": {
      "input": "prices = [7, 1, 5, 3, 6, 4]",
      "output": "5"
    },
    "code": {
      "javascript": "function maxProfit(prices) {\n  let minPrice = Infinity;\n  let maxProfit = 0;\n  for (let price of prices) {\n    if (price < minPrice) minPrice = price;\n    const profit = price - minPrice;\n    if (profit > maxProfit) maxProfit = profit;\n  }\n  return maxProfit;\n}"
    }
  },
  {
    "id": "valid-anagram",
    "title": "Valid Anagram",
    "category": "String",
    "difficulty": "Easy",
    "description": "Determine if string t is an anagram of s.",
    "initialData": [
      "a",
      "n",
      "a",
      "g",
      "r",
      "a",
      "m"
    ],
    "visualType": "ARRAY",
    "complexity": {
      "time": "O(N)",
      "space": "O(1)"
    },
    "code": {
      "javascript": "function isAnagram(s, t) {\n  if (s.length !== t.length) return false;\n  const count = {};\n  for (let char of s) count[char] = (count[char] || 0) + 1;\n  for (let char of t) {\n    if (!count[char]) return false;\n    count[char]--;\n  }\n  return true;\n}"
    }
  },
  {
    "id": "reverse-linked-list",
    "title": "Reverse Linked List",
    "category": "Linked List",
    "difficulty": "Easy",
    "description": "Reverse a singly linked list in-place.",
    "initialData": [
      1,
      2,
      3,
      4,
      5
    ],
    "visualType": "LINKED_LIST",
    "complexity": {
      "time": "O(N)",
      "space": "O(1)"
    },
    "code": {
      "javascript": "function reverseList(head) {\n  let prev = null, curr = head;\n  while (curr) {\n    let next = curr.next;\n    curr.next = prev;\n    prev = curr;\n    curr = next;\n  }\n  return prev;\n}"
    }
  },
  {
    "id": "linked-list-cycle",
    "title": "Linked List Cycle",
    "category": "Linked List",
    "difficulty": "Easy",
    "description": "Detect if a cycle exists in the linked list using Floyd's algorithm.",
    "initialData": [
      3,
      2,
      0,
      -4
    ],
    "visualType": "LINKED_LIST",
    "complexity": {
      "time": "O(N)",
      "space": "O(1)"
    },
    "code": {
      "javascript": "function hasCycle(head) {\n  let slow = head, fast = head;\n  while (fast && fast.next) {\n    slow = slow.next;\n    fast = fast.next.next;\n    if (slow === fast) return true;\n  }\n  return false;\n}"
    }
  },
  {
    "id": "spiral-matrix",
    "title": "Spiral Matrix",
    "category": "Matrix",
    "difficulty": "Medium",
    "description": "Return all elements of the matrix in spiral order.",
    "initialData": [
      [
        1,
        2,
        3
      ],
      [
        4,
        5,
        6
      ],
      [
        7,
        8,
        9
      ]
    ],
    "visualType": "MATRIX",
    "complexity": {
      "time": "O(M*N)",
      "space": "O(1)"
    },
    "code": {
      "javascript": "function spiralOrder(matrix) {\n  const res = [];\n  let left = 0, right = matrix[0].length - 1;\n  let top = 0, bottom = matrix.length - 1;\n  while (left <= right && top <= bottom) {\n    for (let i = left; i <= right; i++) res.push(matrix[top][i]);\n    top++;\n    for (let i = top; i <= bottom; i++) res.push(matrix[i][right]);\n    right--;\n    // ... more logic\n  }\n  return res;\n}"
    }
  },
  {
    "id": "maximum-depth-of-binary-tree",
    "title": "Maximum Depth of Binary Tree",
    "category": "Binary Tree",
    "difficulty": "Easy",
    "description": "Find the maximum depth of a binary tree.",
    "initialData": [
      3,
      9,
      20,
      null,
      null,
      15,
      7
    ],
    "visualType": "TREE",
    "complexity": {
      "time": "O(N)",
      "space": "O(N)"
    },
    "code": {
      "javascript": "function maxDepth(root) {\n  if (!root) return 0;\n  return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n}"
    }
  },
  {
    "id": "climbing-stairs",
    "title": "Climbing Stairs",
    "category": "Dynamic Programming",
    "difficulty": "Easy",
    "description": "Calculate how many distinct ways you can climb to the top.",
    "initialData": [
      1,
      1,
      2,
      3,
      5
    ],
    "visualType": "ARRAY",
    "complexity": {
      "time": "O(N)",
      "space": "O(1)"
    },
    "code": {
      "javascript": "function climbStairs(n) {\n  let one = 1, two = 1;\n  for (let i = 0; i < n - 1; i++) {\n    let temp = one;\n    one = one + two;\n    two = temp;\n  }\n  return one;\n}"
    }
  },
  {
    "id": "binary-search",
    "title": "Binary Search",
    "category": "Searching",
    "difficulty": "Easy",
    "description": "Search for a target in a sorted array in logarithmic time.",
    "initialData": [
      -1,
      0,
      3,
      5,
      9,
      12
    ],
    "visualType": "ARRAY",
    "complexity": {
      "time": "O(log N)",
      "space": "O(1)"
    },
    "code": {
      "javascript": "function search(nums, target) {\n  let left = 0, right = nums.length - 1;\n  while (left <= right) {\n    let mid = Math.floor((left + right) / 2);\n    if (nums[mid] === target) return mid;\n    if (nums[mid] < target) left = mid + 1;\n    else right = mid - 1;\n  }\n  return -1;\n}"
    }
  },
  {
    "id": "contains-duplicate",
    "title": "Contains Duplicate",
    "category": "Array",
    "difficulty": "Easy",
    "description": "Return true if any value appears twice in the array.",
    "initialData": [
      1,
      2,
      3,
      1
    ],
    "visualType": "ARRAY",
    "complexity": {
      "time": "O(N)",
      "space": "O(N)"
    },
    "code": {
      "javascript": "function containsDuplicate(nums) {\n  const set = new Set();\n  for (let n of nums) {\n    if (set.has(n)) return true;\n    set.add(n);\n  }\n  return false;\n}"
    }
  },
  {
    "id": "product-of-array-except-self",
    "title": "Product of Array Except Self",
    "category": "Array",
    "difficulty": "Medium",
    "description": "Calculate product of all elements except current without division.",
    "initialData": [
      1,
      2,
      3,
      4
    ],
    "visualType": "ARRAY",
    "complexity": {
      "time": "O(N)",
      "space": "O(1)"
    },
    "code": {
      "javascript": "function productExceptSelf(nums) {\n  const res = new Array(nums.length).fill(1);\n  let prefix = 1;\n  for (let i = 0; i < nums.length; i++) {\n    res[i] = prefix;\n    prefix *= nums[i];\n  }\n  let suffix = 1;\n  for (let i = nums.length - 1; i >= 0; i--) {\n    res[i] *= suffix;\n    suffix *= nums[i];\n  }\n  return res;\n}"
    }
  },
  {
    "id": "maximum-subarray",
    "title": "Maximum Subarray",
    "category": "Array",
    "difficulty": "Medium",
    "description": "Find contiguous subarray with the largest sum.",
    "initialData": [
      -2,
      1,
      -3,
      4,
      -1,
      2,
      1,
      -5,
      4
    ],
    "visualType": "ARRAY",
    "complexity": {
      "time": "O(N)",
      "space": "O(1)"
    },
    "code": {
      "javascript": "function maxSubArray(nums) {\n  let maxSum = nums[0], curSum = 0;\n  for (let n of nums) {\n    if (curSum < 0) curSum = 0;\n    curSum += n;\n    maxSum = Math.max(maxSum, curSum);\n  }\n  return maxSum;\n}"
    }
  },
  {
    "id": "maximum-product-subarray",
    "title": "Maximum Product Subarray",
    "category": "Array",
    "difficulty": "Medium",
    "description": "Find contiguous subarray with the largest product.",
    "initialData": [
      2,
      3,
      -2,
      4
    ],
    "visualType": "ARRAY",
    "complexity": {
      "time": "O(N)",
      "space": "O(1)"
    },
    "code": {
      "javascript": "function maxProduct(nums) {\n  let curMax = 1, curMin = 1, res = Math.max(...nums);\n  for (let n of nums) {\n    let tmp = curMax * n;\n    curMax = Math.max(n * curMax, n * curMin, n);\n    curMin = Math.min(tmp, n * curMin, n);\n    res = Math.max(res, curMax);\n  }\n  return res;\n}"
    }
  },
  {
    "id": "find-minimum-in-rotated-sorted-array",
    "title": "Find Minimum in Rotated Sorted Array",
    "category": "Array",
    "difficulty": "Medium",
    "description": "Find minimum element in an O(log n) time.",
    "initialData": [
      3,
      4,
      5,
      1,
      2
    ],
    "visualType": "ARRAY",
    "complexity": {
      "time": "O(log N)",
      "space": "O(1)"
    },
    "code": {
      "javascript": "function findMin(nums) {\n  let L = 0, R = nums.length - 1;\n  while (L < R) {\n    let M = Math.floor((L + R) / 2);\n    if (nums[M] > nums[R]) L = M + 1;\n    else R = M;\n  }\n  return nums[L];\n}"
    }
  },
  {
    "id": "search-in-rotated-sorted-array",
    "title": "Search in Rotated Sorted Array",
    "category": "Array",
    "difficulty": "Medium",
    "description": "Search for a target in a rotated sorted array.",
    "initialData": [
      4,
      5,
      6,
      7,
      0,
      1,
      2
    ],
    "visualType": "ARRAY",
    "complexity": {
      "time": "O(log N)",
      "space": "O(1)"
    },
    "code": {
      "javascript": "function search(nums, target) {\n  let L = 0, R = nums.length - 1;\n  while (L <= R) {\n    let M = Math.floor((L + R) / 2);\n    if (nums[M] === target) return M;\n    if (nums[L] <= nums[M]) {\n      if (target > nums[M] || target < nums[L]) L = M + 1;\n      else R = M - 1;\n    } else {\n      if (target < nums[M] || target > nums[R]) R = M - 1;\n      else L = M + 1;\n    }\n  }\n  return -1;\n}"
    }
  },
  {
    "id": "3sum",
    "title": "3Sum",
    "category": "Array",
    "difficulty": "Medium",
    "description": "Find all unique triplets that sum to zero.",
    "initialData": [
      -1,
      0,
      1,
      2,
      -1,
      -4
    ],
    "visualType": "ARRAY",
    "complexity": {
      "time": "O(N^2)",
      "space": "O(N)"
    },
    "code": {
      "javascript": "function threeSum(nums) {\n  nums.sort((a,b) => a-b);\n  const res = [];\n  for (let i = 0; i < nums.length; i++) {\n    if (i > 0 && nums[i] === nums[i-1]) continue;\n    let L = i + 1, R = nums.length - 1;\n    while (L < R) {\n      let sum = nums[i] + nums[L] + nums[R];\n      if (sum > 0) R--;\n      else if (sum < 0) L++;\n      else {\n        res.push([nums[i], nums[L], nums[R]]);\n        L++;\n        while (nums[L] === nums[L-1] && L < R) L++;\n      }\n    }\n  }\n  return res;\n}"
    }
  },
  {
    "id": "container-with-most-water",
    "title": "Container With Most Water",
    "category": "Array",
    "difficulty": "Medium",
    "description": "Find two lines that contain the most water.",
    "initialData": [
      1,
      8,
      6,
      2,
      5,
      4,
      8,
      3,
      7
    ],
    "visualType": "ARRAY",
    "complexity": {
      "time": "O(N)",
      "space": "O(1)"
    },
    "code": {
      "javascript": "function maxArea(height) {\n  let L = 0, R = height.length -1, maxA = 0;\n  while (L < R) {\n    maxA = Math.max(maxA, (R - L) * Math.min(height[L], height[R]));\n    if (height[L] < height[R]) L++; else R--;\n  }\n  return maxA;\n}"
    }
  },
  {
    "id": "longest-substring-without-repeating-characters",
    "title": "Longest Substring Without Repeating Characters",
    "category": "String",
    "difficulty": "Medium",
    "description": "Find the length of the longest substring without repeating characters.",
    "initialData": "abcabcbb",
    "visualType": "ARRAY",
    "complexity": {
      "time": "O(N)",
      "space": "O(N)"
    },
    "code": {
      "javascript": "function lengthOfLongestSubstring(s) {\n  let L = 0, maxL = 0, set = new Set();\n  for (let R = 0; R < s.length; R++) {\n    while (set.has(s[R])) { set.delete(s[L]); L++; }\n    set.add(s[R]);\n    maxL = Math.max(maxL, R - L + 1);\n  }\n  return maxL;\n}"
    }
  },
  {
    "id": "longest-repeating-character-replacement",
    "title": "Longest Repeating Character Replacement",
    "category": "String",
    "difficulty": "Medium",
    "description": "Find longest substring with same letter after k replacements.",
    "initialData": "AABABBA",
    "visualType": "ARRAY",
    "complexity": {
      "time": "O(N)",
      "space": "O(1)"
    },
    "code": {
      "javascript": "function characterReplacement(s, k) {\n  let count = {}, maxF = 0, L = 0, res = 0;\n  for (let R = 0; R < s.length; R++) {\n    count[s[R]] = (count[s[R]] || 0) + 1;\n    maxF = Math.max(maxF, count[s[R]]);\n    while ((R - L + 1) - maxF > k) {\n      count[s[L]]--;\n      L++;\n    }\n    res = Math.max(res, R - L + 1);\n  }\n  return res;\n}"
    }
  },
  {
    "id": "minimum-window-substring",
    "title": "Minimum Window Substring",
    "category": "String",
    "difficulty": "Hard",
    "description": "Find the smallest window in S containing all characters of T.",
    "initialData": "ADOBECODEBANC",
    "visualType": "ARRAY",
    "complexity": {
      "time": "O(N)",
      "space": "O(1)"
    },
    "code": {
      "javascript": "function minWindow(s, t) {\n  if (!t) return '';\n  let countT = {}, window = {};\n  for (let c of t) countT[c] = (countT[c] || 0) + 1;\n  let have = 0, need = Object.keys(countT).length, res = [-1, -1], resLen = Infinity, L = 0;\n  for (let R = 0; R < s.length; R++) {\n    let c = s[R];\n    window[c] = (window[c] || 0) + 1;\n    if (countT[c] && window[c] === countT[c]) have++;\n    while (have === need) {\n      if ((R - L + 1) < resLen) { res = [L, R]; resLen = R - L + 1; }\n      window[s[L]]--;\n      if (countT[s[L]] && window[s[L]] < countT[s[L]]) have--;\n      L++;\n    }\n  }\n  return resLen === Infinity ? '' : s.slice(res[0], res[1] + 1);\n}"
    }
  },
  {
    "id": "group-anagrams",
    "title": "Group Anagrams",
    "category": "String",
    "difficulty": "Medium",
    "description": "Group words that are anagrams of each other.",
    "initialData": [
      "eat",
      "tea",
      "tan",
      "ate",
      "nat",
      "bat"
    ],
    "visualType": "ARRAY",
    "complexity": {
      "time": "O(N*K)",
      "space": "O(N*K)"
    },
    "code": {
      "javascript": "function groupAnagrams(strs) {\n  const res = {};\n  for (let s of strs) {\n    const count = new Array(26).fill(0);\n    for (let c of s) count[c.charCodeAt(0) - 97]++;\n    const key = count.join(',');\n    if (!res[key]) res[key] = [];\n    res[key].push(s);\n  }\n  return Object.values(res);\n}"
    }
  },
  {
    "id": "valid-parentheses",
    "title": "Valid Parentheses",
    "category": "String",
    "difficulty": "Easy",
    "description": "Check if brackets are matching.",
    "initialData": "()[]{}",
    "visualType": "STACK",
    "complexity": {
      "time": "O(N)",
      "space": "O(N)"
    },
    "code": {
      "javascript": "function isValid(s) {\n  const stack = [], map = {')':'(', ']':'[', '}':'{'};\n  for (let c of s) {\n    if (map[c]) {\n      if (stack.pop() !== map[c]) return false;\n    } else stack.push(c);\n  }\n  return stack.length === 0;\n}"
    }
  },
  {
    "id": "valid-palindrome",
    "title": "Valid Palindrome",
    "category": "String",
    "difficulty": "Easy",
    "description": "Check if string is a palindrome after cleanup.",
    "initialData": "A man, a plan, a canal: Panama",
    "visualType": "ARRAY",
    "complexity": {
      "time": "O(N)",
      "space": "O(1)"
    },
    "code": {
      "javascript": "function isPalindrome(s) {\n  let cleaned = s.replace(/[^a-z0-9]/gi, '').toLowerCase();\n  let L = 0, R = cleaned.length - 1;\n  while (L < R) {\n    if (cleaned[L] !== cleaned[R]) return false;\n    L++; R--;\n  }\n  return true;\n}"
    }
  },
  {
    "id": "longest-palindromic-substring",
    "title": "Longest Palindromic Substring",
    "category": "String",
    "difficulty": "Medium",
    "description": "Find the longest substring which is a palindrome.",
    "initialData": "babad",
    "visualType": "ARRAY",
    "complexity": {
      "time": "O(N^2)",
      "space": "O(1)"
    },
    "code": {
      "javascript": "function longestPalindrome(s) {\n  let res = '', resLen = 0;\n  for (let i = 0; i < s.length; i++) {\n    // odd\n    let L = i, R = i;\n    while (L >= 0 && R < s.length && s[L] === s[R]) {\n      if ((R - L + 1) > resLen) { res = s.slice(L, R + 1); resLen = R - L + 1; }\n      L--; R++;\n    }\n    // even\n    L = i; R = i + 1;\n    while (L >= 0 && R < s.length && s[L] === s[R]) {\n      if ((R - L + 1) > resLen) { res = s.slice(L, R + 1); resLen = R - L + 1; }\n      L--; R++;\n    }\n  }\n  return res;\n}"
    }
  },
  {
    "id": "palindromic-substrings",
    "title": "Palindromic Substrings",
    "category": "String",
    "difficulty": "Medium",
    "description": "Count total palindromic substrings.",
    "initialData": "aaa",
    "visualType": "ARRAY",
    "complexity": {
      "time": "O(N^2)",
      "space": "O(1)"
    },
    "code": {
      "javascript": "function countSubstrings(s) {\n  let res = 0;\n  for (let i = 0; i < s.length; i++) {\n    // odd\n    res += countPali(s, i, i);\n    // even\n    res += countPali(s, i, i + 1);\n  }\n  return res;\n}\nfunction countPali(s, L, R) {\n  let count = 0;\n  while (L >= 0 && R < s.length && s[L] === s[R]) { count++; L--; R++; }\n  return count;\n}"
    }
  },
  {
    "id": "merge-intervals",
    "title": "Merge Intervals",
    "category": "Interval",
    "difficulty": "Medium",
    "description": "Merge all overlapping intervals.",
    "initialData": [
      [
        1,
        3
      ],
      [
        2,
        6
      ],
      [
        8,
        10
      ],
      [
        15,
        18
      ]
    ],
    "visualType": "ARRAY",
    "complexity": {
      "time": "O(N log N)",
      "space": "O(N)"
    },
    "code": {
      "javascript": "function merge(intervals) {\n  intervals.sort((a,b) => a[0] - b[0]);\n  const res = [intervals[0]];\n  for (let i = 1; i < intervals.length; i++) {\n    let last = res[res.length - 1];\n    if (intervals[i][0] <= last[1]) last[1] = Math.max(last[1], intervals[i][1]);\n    else res.push(intervals[i]);\n  }\n  return res;\n}"
    }
  },
  {
    "id": "insert-interval",
    "title": "Insert Interval",
    "category": "Interval",
    "difficulty": "Medium",
    "description": "Insert a new interval into a sorted list of non-overlapping intervals.",
    "initialData": [
      [
        1,
        3
      ],
      [
        6,
        9
      ],
      [
        2,
        5
      ]
    ],
    "visualType": "ARRAY",
    "complexity": {
      "time": "O(N)",
      "space": "O(N)"
    },
    "code": {
      "javascript": "function insert(intervals, newInterval) {\n  let res = [], i = 0;\n  while (i < intervals.length && intervals[i][1] < newInterval[0]) res.push(intervals[i++]);\n  while (i < intervals.length && intervals[i][0] <= newInterval[1]) {\n    newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\n    newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\n    i++;\n  }\n  res.push(newInterval);\n  while (i < intervals.length) res.push(intervals[i++]);\n  return res;\n}"
    }
  },
  {
    "id": "number-of-islands",
    "title": "Number of Islands",
    "category": "Graph",
    "difficulty": "Medium",
    "description": "Count number of connected '1's (land) in a 2D grid.",
    "initialData": [
      [
        "1",
        "1",
        "1",
        "1",
        "0"
      ],
      [
        "1",
        "1",
        "0",
        "1",
        "0"
      ],
      [
        "1",
        "1",
        "0",
        "0",
        "0"
      ],
      [
        "0",
        "0",
        "0",
        "0",
        "0"
      ]
    ],
    "visualType": "MATRIX",
    "complexity": {
      "time": "O(M*N)",
      "space": "O(M*N)"
    },
    "code": {
      "javascript": "function numIslands(grid) {\n  let count = 0;\n  function dfs(r, c) {\n    if (r < 0 || c < 0 || r >= grid.length || c >= grid[0].length || grid[r][c] === '0') return;\n    grid[r][c] = '0';\n    dfs(r+1, c); dfs(r-1, c); dfs(r, c+1); dfs(r, c-1);\n  }\n  for (let r = 0; r < grid.length; r++) {\n    for (let c = 0; c < grid[0].length; c++) {\n      if (grid[r][c] === '1') { count++; dfs(r, c); }\n    }\n  }\n  return count;\n}"
    }
  },
  {
    "id": "clone-graph",
    "title": "Clone Graph",
    "category": "Graph",
    "difficulty": "Medium",
    "description": "Create a deep copy of a connected undirected graph.",
    "initialData": [
      [
        2,
        4
      ],
      [
        1,
        3
      ],
      [
        2,
        4
      ],
      [
        1,
        3
      ]
    ],
    "visualType": "GRAPH",
    "complexity": {
      "time": "O(V+E)",
      "space": "O(V)"
    },
    "code": {
      "javascript": "function cloneGraph(node) {\n  if (!node) return null;\n  const oldToNew = new Map();\n  function dfs(node) {\n    if (oldToNew.has(node)) return oldToNew.get(node);\n    const copy = new Node(node.val);\n    oldToNew.set(node, copy);\n    for (let nei of node.neighbors) copy.neighbors.push(dfs(nei));\n    return copy;\n  }\n  return dfs(node);\n}"
    }
  },
  {
    "id": "top-k-frequent-elements",
    "title": "Top K Frequent Elements",
    "category": "Heap",
    "difficulty": "Medium",
    "description": "Return the k most frequent elements.",
    "initialData": [
      [
        1,
        1,
        1,
        2,
        2,
        3
      ],
      2
    ],
    "visualType": "ARRAY",
    "complexity": {
      "time": "O(N log k)",
      "space": "O(N)"
    },
    "code": {
      "javascript": "function topKFrequent(nums, k) {\n  const count = {};\n  for (let n of nums) count[n] = (count[n] || 0) + 1;\n  const bucket = Array.from({ length: nums.length + 1 }, () => []);\n  for (let [n, f] of Object.entries(count)) bucket[f].push(parseInt(n));\n  let res = [];\n  for (let i = bucket.length - 1; i >= 0 && res.length < k; i--) {\n    res.push(...bucket[i]);\n  }\n  return res.slice(0, k);\n}"
    }
  },
  {
    "id": "non-overlapping-intervals",
    "title": "Non-overlapping Intervals",
    "category": "Interval",
    "difficulty": "Medium",
    "description": "Find minimum number of intervals to remove to make the rest non-overlapping.",
    "initialData": [
      [
        1,
        2
      ],
      [
        2,
        3
      ],
      [
        3,
        4
      ],
      [
        1,
        3
      ]
    ],
    "visualType": "ARRAY",
    "complexity": {
      "time": "O(N log N)",
      "space": "O(1)"
    },
    "code": {
      "javascript": "function eraseOverlapIntervals(intervals) {\n  intervals.sort((a, b) => a[1] - b[1]);\n  let prevEnd = intervals[0][1], res = 0;\n  for (let i = 1; i < intervals.length; i++) {\n    if (intervals[i][0] < prevEnd) res++;\n    else prevEnd = intervals[i][1];\n  }\n  return res;\n}"
    }
  },
  {
    "id": "subtree-of-another-tree",
    "title": "Subtree of Another Tree",
    "category": "Binary Tree",
    "difficulty": "Easy",
    "description": "Check if a tree contains another tree as a subtree.",
    "initialData": [
      3,
      4,
      5,
      1,
      2,
      4,
      1,
      2
    ],
    "visualType": "TREE",
    "complexity": {
      "time": "O(S*T)",
      "space": "O(H)"
    },
    "code": {
      "javascript": "function isSubtree(root, subRoot) {\n  if (!subRoot) return true;\n  if (!root) return false;\n  if (isSame(root, subRoot)) return true;\n  return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);\n}\nfunction isSame(s, t) {\n  if (!s && !t) return true;\n  if (s && t && s.val === t.val) return isSame(s.left, t.left) && isSame(s.right, t.right);\n  return false;\n}"
    }
  },
  {
    "id": "validate-binary-search-tree",
    "title": "Validate Binary Search Tree",
    "category": "Binary Tree",
    "difficulty": "Medium",
    "description": "Determine if a tree is a valid Binary Search Tree.",
    "initialData": [
      2,
      1,
      3
    ],
    "visualType": "TREE",
    "complexity": {
      "time": "O(N)",
      "space": "O(H)"
    },
    "code": {
      "javascript": "function isValidBST(root) {\n  function validate(node, min, max) {\n    if (!node) return true;\n    if (node.val <= min || node.val >= max) return false;\n    return validate(node.left, min, node.val) && validate(node.right, node.val, max);\n  }\n  return validate(root, -Infinity, Infinity);\n}"
    }
  },
  {
    "id": "kth-smallest-element-in-a-bst",
    "title": "Kth Smallest Element in a BST",
    "category": "Binary Tree",
    "difficulty": "Medium",
    "description": "Find the kth smallest value in a BST.",
    "initialData": [
      [
        3,
        1,
        4,
        null,
        2
      ],
      1
    ],
    "visualType": "TREE",
    "complexity": {
      "time": "O(H + k)",
      "space": "O(H)"
    },
    "code": {
      "javascript": "function kthSmallest(root, k) {\n  let n = 0, stack = [], cur = root;\n  while (cur || stack.length) {\n    while (cur) { stack.push(cur); cur = cur.left; }\n    cur = stack.pop(); n++;\n    if (n === k) return cur.val;\n    cur = cur.right;\n  }\n}"
    }
  },
  {
    "id": "lowest-common-ancestor-of-a-binary-search-tree",
    "title": "Lowest Common Ancestor of a BST",
    "category": "Binary Tree",
    "difficulty": "Easy",
    "description": "Find the lowest common ancestor of two nodes in a BST.",
    "initialData": [
      [
        6,
        2,
        8,
        0,
        4,
        7,
        9,
        null,
        null,
        3,
        5
      ],
      2,
      8
    ],
    "visualType": "TREE",
    "complexity": {
      "time": "O(H)",
      "space": "O(1)"
    },
    "code": {
      "javascript": "function lowestCommonAncestor(root, p, q) {\n  let cur = root;\n  while (cur) {\n    if (p.val > cur.val && q.val > cur.val) cur = cur.right;\n    else if (p.val < cur.val && q.val < cur.val) cur = cur.left;\n    else return cur;\n  }\n}"
    }
  },
  {
    "id": "set-matrix-zeroes",
    "title": "Set Matrix Zeroes",
    "category": "Matrix",
    "difficulty": "Medium",
    "description": "If an element is 0, set its entire row and column to 0.",
    "initialData": [
      [
        1,
        1,
        1
      ],
      [
        1,
        0,
        1
      ],
      [
        1,
        1,
        1
      ]
    ],
    "visualType": "MATRIX",
    "complexity": {
      "time": "O(M*N)",
      "space": "O(1)"
    },
    "code": {
      "javascript": "function setZeroes(matrix) {\n  let R = matrix.length, C = matrix[0].length, row0 = false;\n  for (let r = 0; r < R; r++) {\n    for (let c = 0; c < C; c++) {\n      if (matrix[r][c] === 0) {\n        matrix[0][c] = 0;\n        if (r > 0) matrix[r][0] = 0; else row0 = true;\n      }\n    }\n  }\n  for (let r = 1; r < R; r++) {\n    for (let c = 1; c < C; c++) {\n      if (matrix[0][c] === 0 || matrix[r][0] === 0) matrix[r][c] = 0;\n    }\n  }\n  if (matrix[0][0] === 0) for (let r = 0; r < R; r++) matrix[r][0] = 0;\n  if (row0) for (let c = 0; c < C; c++) matrix[0][c] = 0;\n}"
    }
  },
  {
    "id": "rotate-image",
    "title": "Rotate Image",
    "category": "Matrix",
    "difficulty": "Medium",
    "description": "Rotate a squared n x n matrix by 90 degrees clockwise.",
    "initialData": [
      [
        1,
        2,
        3
      ],
      [
        4,
        5,
        6
      ],
      [
        7,
        8,
        9
      ]
    ],
    "visualType": "MATRIX",
    "complexity": {
      "time": "O(N^2)",
      "space": "O(1)"
    },
    "code": {
      "javascript": "function rotate(matrix) {\n  let L = 0, R = matrix.length - 1;\n  while (L < R) {\n    for (let i = 0; i < R - L; i++) {\n      let T = L, B = R, tmp = matrix[T][L + i];\n      matrix[T][L + i] = matrix[B - i][L];\n      matrix[B - i][L] = matrix[B][R - i];\n      matrix[B][R - i] = matrix[T + i][R];\n      matrix[T + i][R] = tmp;\n    }\n    L++; R--;\n  }\n}"
    }
  },
  {
    "id": "word-search",
    "title": "Word Search",
    "category": "Matrix",
    "difficulty": "Medium",
    "description": "Check if a word exists in a grid of characters.",
    "initialData": [
      [
        [
          "A",
          "B",
          "C",
          "E"
        ],
        [
          "S",
          "F",
          "C",
          "S"
        ],
        [
          "A",
          "D",
          "E",
          "E"
        ]
      ],
      "ABCCED"
    ],
    "visualType": "MATRIX",
    "complexity": {
      "time": "O(N * M * 4^L)",
      "space": "O(L)"
    },
    "code": {
      "javascript": "function exist(board, word) {\n  let ROWS = board.length, COLS = board[0].length, path = new Set();\n  function dfs(r, c, i) {\n    if (i === word.length) return true;\n    if (r < 0 || c < 0 || r >= ROWS || c >= COLS || board[r][c] !== word[i] || path.has(`${r},${c}`)) return false;\n    path.add(`${r},${c}`);\n    let res = dfs(r+1,c,i+1) || dfs(r-1,c,i+1) || dfs(r,c+1,i+1) || dfs(r,c-1,i+1);\n    path.delete(`${r},${c}`);\n    return res;\n  }\n  for (let r = 0; r < ROWS; r++) {\n    for (let c = 0; c < COLS; c++) {\n      if (dfs(r, c, 0)) return true;\n    }\n  } return false;\n}"
    }
  },
  {
    "id": "course-schedule",
    "title": "Course Schedule",
    "category": "Graph",
    "difficulty": "Medium",
    "description": "Determine if you can finish all courses given prerequisites.",
    "initialData": [
      2,
      [
        [
          1,
          0
        ]
      ]
    ],
    "visualType": "GRAPH",
    "complexity": {
      "time": "O(V+E)",
      "space": "O(V+E)"
    },
    "code": {
      "javascript": "function canFinish(numCourses, prerequisites) {\n  const adj = Array.from({ length: numCourses }, () => []);\n  for (let [c, p] of prerequisites) adj[p].push(c);\n  const visit = new Set();\n  function dfs(c) {\n    if (visit.has(c)) return false;\n    if (adj[c].length === 0) return true;\n    visit.add(c);\n    for (let nei of adj[c]) if (!dfs(nei)) return false;\n    visit.delete(c); adj[c] = []; return true;\n  }\n  for (let i = 0; i < numCourses; i++) if (!dfs(i)) return false;\n  return true;\n}"
    }
  },
  {
    "id": "pacific-atlantic-water-flow",
    "title": "Pacific Atlantic Water Flow",
    "category": "Graph",
    "difficulty": "Medium",
    "description": "Find grid cells that can flow to both Pacific and Atlantic oceans.",
    "initialData": [
      [
        1,
        2,
        2,
        3,
        5
      ],
      [
        3,
        2,
        3,
        4,
        4
      ],
      [
        2,
        4,
        5,
        3,
        1
      ],
      [
        6,
        7,
        1,
        4,
        5
      ],
      [
        5,
        1,
        1,
        2,
        4
      ]
    ],
    "visualType": "MATRIX",
    "complexity": {
      "time": "O(M*N)",
      "space": "O(M*N)"
    },
    "code": {
      "javascript": "function pacificAtlantic(heights) {\n  let R = heights.length, C = heights[0].length, pac = new Set(), atl = new Set();\n  function dfs(r, c, visit, prevH) {\n    if (r < 0 || c < 0 || r >= R || c >= C || visit.has(`${r},${c}`) || heights[r][c] < prevH) return;\n    visit.add(`${r},${c}`);\n    dfs(r+1,c,visit,heights[r][c]); dfs(r-1,c,visit,heights[r][c]); dfs(r,c+1,visit,heights[r][c]); dfs(r,c-1,visit,heights[r][c]);\n  }\n  for (let c = 0; c < C; c++) { dfs(0, c, pac, heights[0][c]); dfs(R - 1, c, atl, heights[R - 1][c]); }\n  for (let r = 0; r < R; r++) { dfs(r, 0, pac, heights[r][0]); dfs(r, C - 1, atl, heights[r][C - 1]); }\n  let res = [];\n  for (let r = 0; r < R; r++) for (let c = 0; c < C; c++) if (pac.has(`${r},${c}`) && atl.has(`${r},${c}`)) res.push([r, c]);\n  return res;\n}"
    }
  },
  {
    "id": "word-break",
    "title": "Word Break",
    "category": "Dynamic Programming",
    "difficulty": "Medium",
    "description": "Check if a string can be segmented into space-separated sequence of dictionary words.",
    "initialData": [
      "leetcode",
      [
        "leet",
        "code"
      ]
    ],
    "visualType": "ARRAY",
    "complexity": {
      "time": "O(N^2 * M)",
      "space": "O(N)"
    },
    "code": {
      "javascript": "function wordBreak(s, wordDict) {\n  const dp = new Array(s.length + 1).fill(false);\n  dp[s.length] = true;\n  for (let i = s.length - 1; i >= 0; i--) {\n    for (let w of wordDict) {\n      if (i + w.length <= s.length && s.slice(i, i + w.length) === w) dp[i] = dp[i + w.length];\n      if (dp[i]) break;\n    }\n  }\n  return dp[0];\n}"
    }
  },
  {
    "id": "house-robber",
    "title": "House Robber",
    "category": "Dynamic Programming",
    "difficulty": "Medium",
    "description": "Find max amount of money you can rob without robbing adjacent houses.",
    "initialData": [
      1,
      2,
      3,
      1
    ],
    "visualType": "ARRAY",
    "complexity": {
      "time": "O(N)",
      "space": "O(1)"
    },
    "code": {
      "javascript": "function rob(nums) {\n  let r1 = 0, r2 = 0;\n  for (let n of nums) {\n    let tmp = Math.max(n + r1, r2);\n    r1 = r2; r2 = tmp;\n  }\n  return r2;\n}"
    }
  },
  {
    "id": "house-robber-ii",
    "title": "House Robber II",
    "category": "Dynamic Programming",
    "difficulty": "Medium",
    "description": "Rob houses in a circle.",
    "initialData": [
      2,
      3,
      2
    ],
    "visualType": "ARRAY",
    "complexity": {
      "time": "O(N)",
      "space": "O(1)"
    },
    "code": {
      "javascript": "function rob(nums) {\n  return Math.max(nums[0], helper(nums.slice(1)), helper(nums.slice(0, -1)));\n}\nfunction helper(nums) {\n  let r1 = 0, r2 = 0;\n  for (let n of nums) { let tmp = Math.max(n + r1, r2); r1 = r2; r2 = tmp; }\n  return r2;\n}"
    }
  },
  {
    "id": "decode-ways",
    "title": "Decode Ways",
    "category": "Dynamic Programming",
    "difficulty": "Medium",
    "description": "Find total number of ways to decode a digit string.",
    "initialData": "226",
    "visualType": "ARRAY",
    "complexity": {
      "time": "O(N)",
      "space": "O(N)"
    },
    "code": {
      "javascript": "function numDecodings(s) {\n  const dp = { [s.length]: 1 };\n  for (let i = s.length - 1; i >= 0; i--) {\n    if (s[i] === '0') dp[i] = 0;\n    else dp[i] = dp[i + 1];\n    if (i + 1 < s.length && (s[i] === '1' || (s[i] === '2' && '0123456'.includes(s[i + 1])))) dp[i] += dp[i + 2];\n  }\n  return dp[0];\n}"
    }
  },
  {
    "id": "unique-paths",
    "title": "Unique Paths",
    "category": "Dynamic Programming",
    "difficulty": "Medium",
    "description": "Find total unique paths to bottom-right corner of a grid.",
    "initialData": [
      3,
      7
    ],
    "visualType": "MATRIX",
    "complexity": {
      "time": "O(M*N)",
      "space": "O(N)"
    },
    "code": {
      "javascript": "function uniquePaths(m, n) {\n  let row = new Array(n).fill(1);\n  for (let i = 0; i < m - 1; i++) {\n    let nextRow = new Array(n).fill(1);\n    for (let j = n - 2; j >= 0; j--) nextRow[j] = nextRow[j + 1] + row[j];\n    row = nextRow;\n  }\n  return row[0];\n}"
    }
  },
  {
    "id": "jump-game",
    "title": "Jump Game",
    "category": "Dynamic Programming",
    "difficulty": "Medium",
    "description": "Determine if you can reach the last index.",
    "initialData": [
      2,
      3,
      1,
      1,
      4
    ],
    "visualType": "ARRAY",
    "complexity": {
      "time": "O(N)",
      "space": "O(1)"
    },
    "code": {
      "javascript": "function canJump(nums) {\n  let goal = nums.length - 1;\n  for (let i = nums.length - 1; i >= 0; i--) if (i + nums[i] >= goal) goal = i;\n  return goal === 0;\n}"
    }
  },
  {
    "id": "find-median-from-data-stream",
    "title": "Median Finder",
    "category": "Heap",
    "difficulty": "Hard",
    "description": "Find the median of a stream of numbers.",
    "initialData": [
      1,
      2,
      3
    ],
    "visualType": "ARRAY",
    "complexity": {
      "time": "O(log N)",
      "space": "O(N)"
    },
    "code": {
      "javascript": "class MedianFinder {\n  constructor() { this.small = new MaxHeap(); this.large = new MinHeap(); }\n  addNum(num) {\n    this.small.push(num);\n    if (this.small.size() && this.large.size() && this.small.peek() > this.large.peek()) this.large.push(this.small.pop());\n    if (this.small.size() > this.large.size() + 1) this.large.push(this.small.pop());\n    if (this.large.size() > this.small.size() + 1) this.small.push(this.large.pop());\n  }\n  findMedian() {\n    if (this.small.size() > this.large.size()) return this.small.peek();\n    if (this.large.size() > this.small.size()) return this.large.peek();\n    return (this.small.peek() + this.large.peek()) / 2;\n  }\n}"
    }
  },
  {
    "id": "missing-number",
    "title": "Missing Number",
    "category": "Binary",
    "difficulty": "Easy",
    "description": "Find the missing number in the range [0, n].",
    "initialData": [
      3,
      0,
      1
    ],
    "visualType": "ARRAY",
    "complexity": {
      "time": "O(N)",
      "space": "O(1)"
    },
    "code": {
      "javascript": "function missingNumber(nums) {\n  let res = nums.length;\n  for (let i = 0; i < nums.length; i++) res += i - nums[i];\n  return res;\n}"
    }
  },
  {
    "id": "counting-bits",
    "title": "Counting Bits",
    "category": "Binary",
    "difficulty": "Easy",
    "description": "Return an array of number of 1 bits for each number from 0 to n.",
    "initialData": 5,
    "visualType": "ARRAY",
    "complexity": {
      "time": "O(N)",
      "space": "O(N)"
    },
    "code": {
      "javascript": "function countBits(n) {\n  const res = new Array(n + 1).fill(0);\n  let offset = 1;\n  for (let i = 1; i <= n; i++) {\n    if (offset * 2 === i) offset = i;\n    res[i] = 1 + res[i - offset];\n  }\n  return res;\n}"
    }
  },
  {
    "id": "sum-of-two-integers",
    "title": "Sum of Two Integers",
    "category": "Binary",
    "difficulty": "Medium",
    "description": "Sum two integers without using + or - operators.",
    "initialData": [
      1,
      2
    ],
    "visualType": "ARRAY",
    "complexity": {
      "time": "O(1)",
      "space": "O(1)"
    },
    "code": {
      "javascript": "function getSum(a, b) {\n  while (b !== 0) {\n    let tmp = (a & b) << 1;\n    a = a ^ b;\n    b = tmp;\n  } return a;\n}"
    }
  },
  {
    "id": "number-of-1-bits",
    "title": "Number of 1 Bits",
    "category": "Binary",
    "difficulty": "Easy",
    "description": "Count how many '1' bits are in an unsigned integer.",
    "initialData": 11,
    "visualType": "ARRAY",
    "complexity": {
      "time": "O(1)",
      "space": "O(1)"
    },
    "code": {
      "javascript": "function hammingWeight(n) {\n  let res = 0;\n  while (n) { n &= (n - 1); res++; } return res;\n}"
    }
  },
  {
    "id": "reverse-bits",
    "title": "Reverse Bits",
    "category": "Binary",
    "difficulty": "Easy",
    "description": "Reverse bits of a 32-bit unsigned integer.",
    "initialData": 43261596,
    "visualType": "ARRAY",
    "complexity": {
      "time": "O(1)",
      "space": "O(1)"
    },
    "code": {
      "javascript": "function reverseBits(n) {\n  let res = 0;\n  for (let i = 0; i < 32; i++) {\n    let bit = (n >> i) & 1;\n    res = res | (bit << (31 - i));\n  } return res >>> 0;\n}"
    }
  },
  {
    "id": "coin-change",
    "title": "Coin Change",
    "category": "Dynamic Programming",
    "difficulty": "Medium",
    "description": "Fewest coins to make up an amount.",
    "initialData": [
      [
        1,
        2,
        5
      ],
      11
    ],
    "visualType": "ARRAY",
    "complexity": {
      "time": "O(amount * n)",
      "space": "O(amount)"
    },
    "code": {
      "javascript": "function coinChange(coins, amount) {\n  const dp = new Array(amount + 1).fill(Infinity);\n  dp[0] = 0;\n  for (let a = 1; a <= amount; a++) {\n    for (let c of coins) {\n      if (a - c >= 0) dp[a] = Math.min(dp[a], 1 + dp[a - c]);\n    }\n  }\n  return dp[amount] === Infinity ? -1 : dp[amount];\n}"
    }
  },
  {
    "id": "longest-increasing-subsequence",
    "title": "Longest Increasing Subsequence",
    "category": "Dynamic Programming",
    "difficulty": "Medium",
    "description": "Find the length of the longest strictly increasing subsequence.",
    "initialData": [
      10,
      9,
      2,
      5,
      3,
      7,
      101,
      18
    ],
    "visualType": "ARRAY",
    "complexity": {
      "time": "O(N^2)",
      "space": "O(N)"
    },
    "code": {
      "javascript": "function lengthOfLIS(nums) {\n  const dp = new Array(nums.length).fill(1);\n  for (let i = nums.length - 1; i >= 0; i--) {\n    for (let j = i + 1; j < nums.length; j++) {\n      if (nums[i] < nums[j]) dp[i] = Math.max(dp[i], 1 + dp[j]);\n    }\n  }\n  return Math.max(...dp);\n}"
    }
  },
  {
    "id": "longest-common-subsequence",
    "title": "Longest Common Subsequence",
    "category": "Dynamic Programming",
    "difficulty": "Medium",
    "description": "Find the length of the longest common subsequence between two strings.",
    "initialData": [
      "abcde",
      "ace"
    ],
    "visualType": "MATRIX",
    "complexity": {
      "time": "O(N*M)",
      "space": "O(N*M)"
    },
    "code": {
      "javascript": "function longestCommonSubsequence(text1, text2) {\n  const dp = Array.from({ length: text1.length + 1 }, () => new Array(text2.length + 1).fill(0));\n  for (let i = text1.length - 1; i >= 0; i--) {\n    for (let j = text2.length - 1; j >= 0; j--) {\n      if (text1[i] === text2[j]) dp[i][j] = 1 + dp[i+1][j+1];\n      else dp[i][j] = Math.max(dp[i+1][j], dp[i][j+1]);\n    }\n  }\n  return dp[0][0];\n}"
    }
  },
  {
    "id": "combination-sum",
    "title": "Combination Sum",
    "category": "Dynamic Programming",
    "difficulty": "Medium",
    "description": "Find all unique combinations that sum to target.",
    "initialData": [
      [
        2,
        3,
        6,
        7
      ],
      7
    ],
    "visualType": "ARRAY",
    "complexity": {
      "time": "O(2^T)",
      "space": "O(T)"
    },
    "code": {
      "javascript": "function combinationSum(candidates, target) {\n  const res = [];\n  function dfs(i, cur, total) {\n    if (total === target) { res.push([...cur]); return; }\n    if (i >= candidates.length || total > target) return;\n    cur.push(candidates[i]);\n    dfs(i, cur, total + candidates[i]);\n    cur.pop();\n    dfs(i + 1, cur, total);\n  }\n  dfs(0, [], 0); return res;\n}"
    }
  },
  {
    "id": "longest-consecutive-sequence",
    "title": "Longest Consecutive Sequence",
    "category": "Graph",
    "difficulty": "Medium",
    "description": "Find the length of the longest consecutive elements sequence.",
    "initialData": [
      100,
      4,
      200,
      1,
      3,
      2
    ],
    "visualType": "ARRAY",
    "complexity": {
      "time": "O(N)",
      "space": "O(N)"
    },
    "code": {
      "javascript": "function longestConsecutive(nums) {\n  const set = new Set(nums);\n  let longest = 0;\n  for (let n of nums) {\n    if (!set.has(n - 1)) {\n      let length = 0;\n      while (set.has(n + length)) length++;\n      longest = Math.max(longest, length);\n    }\n  }\n  return longest;\n}"
    }
  },
  {
    "id": "alien-dictionary",
    "title": "Alien Dictionary",
    "category": "Graph",
    "difficulty": "Hard",
    "description": "Derive the order of characters in an alien language.",
    "initialData": [
      "wrt",
      "wrf",
      "er",
      "ett",
      "rftt"
    ],
    "visualType": "GRAPH",
    "complexity": {
      "time": "O(C)",
      "space": "O(V+E)"
    },
    "code": {
      "javascript": "// Topological Sort Logic\n function alienOrder(words) { \n  let adj = {}, visit = {}; let res = [];\n  for (let w of words) for (let c of w) adj[c] = new Set();\n  for (let i=0; i < words.length -1; i++) {\n    let w1 = words[i], w2 = words[i+1];\n    let minLen = Math.min(w1.length, w2.length);\n    for (let j=0; j < minLen; j++) {\n      if (w1[j] !== w2[j]) { adj[w1[j]].add(w2[j]); break; }\n    }\n  }\n  function dfs(c) {\n    if (visit[c] === 'visiting') return true;\n    if (visit[c] === 'visited') return false;\n    visit[c] = 'visiting';\n    for (let nei of adj[c]) if (dfs(nei)) return true;\n    visit[c] = 'visited'; res.push(c); return false;\n  }\n  for (let c in adj) if (dfs(c)) return '';\n  return res.reverse().join('');\n}"
    }
  },
  {
    "id": "graph-valid-tree",
    "title": "Graph Valid Tree",
    "category": "Graph",
    "difficulty": "Medium",
    "description": "Check if a graph is a valid tree.",
    "initialData": [
      5,
      [
        [
          0,
          1
        ],
        [
          0,
          2
        ],
        [
          0,
          3
        ],
        [
          1,
          4
        ]
      ]
    ],
    "visualType": "GRAPH",
    "complexity": {
      "time": "O(V+E)",
      "space": "O(V+E)"
    },
    "code": {
      "javascript": "function validTree(n, edges) {\n  if (!n) return true;\n  const adj = Array.from({ length: n }, () => []);\n  for (let [u, v] of edges) { adj[u].push(v); adj[v].push(u); }\n  const visit = new Set();\n  function dfs(i, prev) {\n    if (visit.has(i)) return false;\n    visit.add(i);\n    for (let nei of adj[i]) {\n      if (nei === prev) continue;\n      if (!dfs(nei, i)) return false;\n    }\n    return true;\n  }\n  return dfs(0, -1) && visit.size === n;\n}"
    }
  },
  {
    "id": "number-of-connected-components",
    "title": "Connected Components",
    "category": "Graph",
    "difficulty": "Medium",
    "description": "Count the number of connected components in an undirected graph.",
    "initialData": [
      5,
      [
        [
          0,
          1
        ],
        [
          1,
          2
        ],
        [
          3,
          4
        ]
      ]
    ],
    "visualType": "GRAPH",
    "complexity": {
      "time": "O(V+E)",
      "space": "O(V+E)"
    },
    "code": {
      "javascript": "function countComponents(n, edges) {\n  const adj = Array.from({ length: n }, () => []);\n  for (let [u, v] of edges) { adj[u].push(v); adj[v].push(u); }\n  const visit = new Set();\n  let res = 0;\n  function dfs(i) {\n    visit.add(i);\n    for (let nei of adj[i]) if (!visit.has(nei)) dfs(nei);\n  }\n  for (let i = 0; i < n; i++) {\n    if (!visit.has(i)) { res++; dfs(i); }\n  }\n  return res;\n}"
    }
  },
  {
    "id": "meeting-rooms",
    "title": "Meeting Rooms",
    "category": "Interval",
    "difficulty": "Easy",
    "description": "Determine if a person can attend all meetings.",
    "initialData": [
      [
        0,
        30
      ],
      [
        5,
        10
      ],
      [
        15,
        20
      ]
    ],
    "visualType": "ARRAY",
    "complexity": {
      "time": "O(N log N)",
      "space": "O(1)"
    },
    "code": {
      "javascript": "function canAttendMeetings(intervals) {\n  intervals.sort((a, b) => a[0] - b[0]);\n  for (let i = 0; i < intervals.length - 1; i++) {\n    if (intervals[i][1] > intervals[i+1][0]) return false;\n  }\n  return true;\n}"
    }
  },
  {
    "id": "meeting-rooms-ii",
    "title": "Meeting Rooms II",
    "category": "Interval",
    "difficulty": "Medium",
    "description": "Find the minimum number of conference rooms required.",
    "initialData": [
      [
        0,
        30
      ],
      [
        5,
        10
      ],
      [
        15,
        20
      ]
    ],
    "visualType": "ARRAY",
    "complexity": {
      "time": "O(N log N)",
      "space": "O(N)"
    },
    "code": {
      "javascript": "function minMeetingRooms(intervals) {\n  const start = intervals.map(i => i[0]).sort((a,b) => a-b);\n  const end = intervals.map(i => i[1]).sort((a,b) => a-b);\n  let res = 0, count = 0, s = 0, e = 0;\n  while (s < intervals.length) {\n    if (start[s] < end[e]) { s++; count++; }\n    else { e++; count--; }\n    res = Math.max(res, count);\n  }\n  return res;\n}"
    }
  },
  {
    "id": "merge-two-sorted-lists",
    "title": "Merge Two Sorted Lists",
    "category": "Linked List",
    "difficulty": "Easy",
    "description": "Merge two sorted linked lists.",
    "initialData": [
      [
        1,
        2,
        4
      ],
      [
        1,
        3,
        4
      ]
    ],
    "visualType": "LINKED_LIST",
    "complexity": {
      "time": "O(N+M)",
      "space": "O(1)"
    },
    "code": {
      "javascript": "function mergeTwoLists(l1, l2) {\n  const dummy = new ListNode();\n  let tail = dummy;\n  while (l1 && l2) {\n    if (l1.val < l2.val) { tail.next = l1; l1 = l1.next; }\n    else { tail.next = l2; l2 = l2.next; }\n    tail = tail.next;\n  }\n  tail.next = l1 || l2;\n  return dummy.next;\n}"
    }
  },
  {
    "id": "merge-k-sorted-lists",
    "title": "Merge K Sorted Lists",
    "category": "Linked List",
    "difficulty": "Hard",
    "description": "Merge k sorted linked lists.",
    "initialData": [
      [
        1,
        4,
        5
      ],
      [
        1,
        3,
        4
      ],
      [
        2,
        6
      ]
    ],
    "visualType": "LINKED_LIST",
    "complexity": {
      "time": "O(N log k)",
      "space": "O(k)"
    },
    "code": {
      "javascript": "function mergeKLists(lists) {\n  if (!lists.length) return null;\n  while (lists.length > 1) {\n    let merged = [];\n    for (let i=0; i < lists.length; i += 2) {\n      merged.push(merge(lists[i], lists[i+1]));\n    }\n    lists = merged;\n  }\n  return lists[0];\n}"
    }
  },
  {
    "id": "remove-nth-node-from-end",
    "title": "Remove Nth Node From End",
    "category": "Linked List",
    "difficulty": "Medium",
    "description": "Remove the nth node from the end of the list.",
    "initialData": [
      [
        1,
        2,
        3,
        4,
        5
      ],
      2
    ],
    "visualType": "LINKED_LIST",
    "complexity": {
      "time": "O(N)",
      "space": "O(1)"
    },
    "code": {
      "javascript": "function removeNthFromEnd(head, n) {\n  const dummy = new ListNode(0, head);\n  let left = dummy, right = head;\n  while (n > 0) { right = right.next; n--; }\n  while (right) {\n    left = left.next;\n    right = right.next;\n  }\n  left.next = left.next.next;\n  return dummy.next;\n}"
    }
  },
  {
    "id": "reorder-list",
    "title": "Reorder List",
    "category": "Linked List",
    "difficulty": "Medium",
    "description": "Reorder a linked list to L0->Ln->L1->Ln-1...",
    "initialData": [
      1,
      2,
      3,
      4
    ],
    "visualType": "LINKED_LIST",
    "complexity": {
      "time": "O(N)",
      "space": "O(1)"
    },
    "code": {
      "javascript": "function reorderList(head) {\n  let slow = head, fast = head.next;\n  while (fast && fast.next) { slow = slow.next; fast = fast.next.next; }\n  let second = slow.next; slow.next = null; let prev = null;\n  while (second) { let tmp = second.next; second.next = prev; prev = second; second = tmp; }\n  let first = head; second = prev;\n  while (second) { let t1 = first.next, t2 = second.next; first.next = second; second.next = t1; first = t1; second = t2; }\n}"
    }
  },
  {
    "id": "same-tree",
    "title": "Same Tree",
    "category": "Binary Tree",
    "difficulty": "Easy",
    "description": "Check if two binary trees are identical.",
    "initialData": [
      [
        1,
        2,
        3
      ],
      [
        1,
        2,
        3
      ]
    ],
    "visualType": "TREE",
    "complexity": {
      "time": "O(N)",
      "space": "O(H)"
    },
    "code": {
      "javascript": "function isSameTree(p, q) {\n  if (!p && !q) return true;\n  if (p && q && p.val === q.val) return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n  return false;\n}"
    }
  },
  {
    "id": "binary-tree-level-order-traversal",
    "title": "Binary Tree Level Order Traversal",
    "category": "Binary Tree",
    "difficulty": "Medium",
    "description": "Return level order traversal of a tree.",
    "initialData": [
      3,
      9,
      20,
      null,
      null,
      15,
      7
    ],
    "visualType": "TREE",
    "complexity": {
      "time": "O(N)",
      "space": "O(N)"
    },
    "code": {
      "javascript": "function levelOrder(root) {\n  if (!root) return [];\n  const res = [], q = [root];\n  while (q.length) {\n    const level = [];\n    for (let i = q.length; i > 0; i--) {\n      let node = q.shift(); level.push(node.val);\n      if (node.left) q.push(node.left);\n      if (node.right) q.push(node.right);\n    }\n    res.push(level);\n  }\n  return res;\n}"
    }
  },
  {
    "id": "binary-tree-maximum-path-sum",
    "title": "Binary Tree Maximum Path Sum",
    "category": "Binary Tree",
    "difficulty": "Hard",
    "description": "Find the maximum path sum in a binary tree.",
    "initialData": [
      -10,
      9,
      20,
      null,
      null,
      15,
      7
    ],
    "visualType": "TREE",
    "complexity": {
      "time": "O(N)",
      "space": "O(H)"
    },
    "code": {
      "javascript": "function maxPathSum(root) {\n  let res = -Infinity;\n  function dfs(node) {\n    if (!node) return 0;\n    let leftMax = Math.max(0, dfs(node.left));\n    let rightMax = Math.max(0, dfs(node.right));\n    res = Math.max(res, node.val + leftMax + rightMax);\n    return node.val + Math.max(leftMax, rightMax);\n  }\n  dfs(root); return res;\n}"
    }
  },
  {
    "id": "serialize-and-deserialize-binary-tree",
    "title": "Serialize and Deserialize Binary Tree",
    "category": "Binary Tree",
    "difficulty": "Hard",
    "description": "Convert binary tree to string and back.",
    "initialData": [
      1,
      2,
      3,
      null,
      null,
      4,
      5
    ],
    "visualType": "TREE",
    "complexity": {
      "time": "O(N)",
      "space": "O(N)"
    },
    "code": {
      "javascript": "function serialize(root) {\n  const res = [];\n  function dfs(node) {\n    if (!node) { res.push('N'); return; }\n    res.push(node.val.toString());\n    dfs(node.left); dfs(node.right);\n  }\n  dfs(root); return res.join(',');\n}\nfunction deserialize(data) {\n  const vals = data.split(','); let i = 0;\n  function dfs() {\n    if (vals[i] === 'N') { i++; return null; }\n    let node = new TreeNode(parseInt(vals[i])); i++;\n    node.left = dfs(); node.right = dfs(); return node;\n  }\n  return dfs();\n}"
    }
  },
  {
    "id": "construct-binary-tree-from-preorder-and-inorder-traversal",
    "title": "Construct Binary Tree",
    "category": "Binary Tree",
    "difficulty": "Medium",
    "description": "Construct binary tree from preorder and inorder traversal arrays.",
    "initialData": [
      [
        3,
        9,
        20,
        15,
        7
      ],
      [
        9,
        3,
        15,
        20,
        7
      ]
    ],
    "visualType": "TREE",
    "complexity": {
      "time": "O(N)",
      "space": "O(N)"
    },
    "code": {
      "javascript": "function buildTree(preorder, inorder) {\n  if (!preorder.length || !inorder.length) return null;\n  let root = new TreeNode(preorder[0]);\n  let mid = inorder.indexOf(preorder[0]);\n  root.left = buildTree(preorder.slice(1, mid + 1), inorder.slice(0, mid));\n  root.right = buildTree(preorder.slice(mid + 1), inorder.slice(mid + 1));\n  return root;\n}"
    }
  },
  {
    "id": "implement-trie",
    "title": "Implement Trie (Prefix Tree)",
    "category": "Trie",
    "difficulty": "Medium",
    "description": "Implement a trie with insert, search, and startsWith methods.",
    "initialData": [
      "apple"
    ],
    "visualType": "TREE",
    "complexity": {
      "time": "O(L)",
      "space": "O(N*L)"
    },
    "code": {
      "javascript": "class TrieNode { constructor() { this.children = {}; this.endOfWord = false; } }\nclass Trie {\n  constructor() { this.root = new TrieNode(); }\n  insert(word) {\n    let cur = this.root;\n    for (let c of word) {\n      if (!cur.children[c]) cur.children[c] = new TrieNode();\n      cur = cur.children[c];\n    }\n    cur.endOfWord = true;\n  }\n  search(word) {\n    let cur = this.root;\n    for (let c of word) {\n      if (!cur.children[c]) return false;\n      cur = cur.children[c];\n    }\n    return cur.endOfWord;\n  }\n}"
    }
  },
  {
    "id": "add-and-search-word",
    "title": "Add and Search Word",
    "category": "Trie",
    "difficulty": "Medium",
    "description": "Design a data structure that supports adding new words and finding if a string matches any previously added string.",
    "initialData": [
      "bad",
      "dad",
      "mad"
    ],
    "visualType": "TREE",
    "complexity": {
      "time": "O(L)",
      "space": "O(N*L)"
    },
    "code": {
      "javascript": "class WordDictionary {\n  constructor() { this.root = { children: {}, end: false }; }\n  addWord(word) {\n    let cur = this.root;\n    for (let c of word) {\n      if (!cur.children[c]) cur.children[c] = { children: {}, end: false };\n      cur = cur.children[c];\n    }\n    cur.end = true;\n  }\n  search(word) {\n    function dfs(j, root) {\n      let cur = root;\n      for (let i = j; i < word.length; i++) {\n        let c = word[i];\n        if (c === '.') {\n          for (let child in cur.children) if (dfs(i + 1, cur.children[child])) return true;\n          return false;\n        } else {\n          if (!cur.children[c]) return false;\n          cur = cur.children[c];\n        }\n      }\n      return cur.end;\n    }\n    return dfs(0, this.root);\n  }\n}"
    }
  },
  {
    "id": "merge-k-sorted-lists-heap",
    "title": "Merge K Sorted Lists (Heap)",
    "category": "Heap",
    "difficulty": "Hard",
    "description": "Merge k sorted lists using a heap.",
    "initialData": [
      [
        1,
        4,
        5
      ],
      [
        1,
        3,
        4
      ],
      [
        2,
        6
      ]
    ],
    "visualType": "LINKED_LIST",
    "complexity": {
      "time": "O(N log k)",
      "space": "O(k)"
    },
    "code": {
      "javascript": "function mergeKLists(lists) {\n  let minHeap = new MinHeap();\n  for (let l of lists) if (l) minHeap.push(l);\n  let dummy = new ListNode(), tail = dummy;\n  while (!minHeap.isEmpty()) {\n    let node = minHeap.pop();\n    tail.next = node; tail = tail.next;\n    if (node.next) minHeap.push(node.next);\n  }\n  return dummy.next;\n}"
    }
  },
  {
    "id": "trapping-rain-water",
    "title": "Trapping Rain Water",
    "category": "Array",
    "difficulty": "Hard",
    "description": "Given n non-negative integers representing an elevation map, compute how much water it can trap after raining.",
    "initialData": [
      0,
      1,
      0,
      2,
      1,
      0,
      1,
      3,
      2,
      1,
      2,
      1
    ],
    "visualType": "ARRAY",
    "complexity": {
      "time": "O(N)",
      "space": "O(1)"
    },
    "code": {
      "javascript": "function trap(height) {\n  let L = 0, R = height.length - 1, leftMax = 0, rightMax = 0, res = 0;\n  while (L < R) {\n    if (height[L] < height[R]) {\n      if (height[L] >= leftMax) leftMax = height[L];\n      else res += leftMax - height[L];\n      L++;\n    } else {\n      if (height[R] >= rightMax) rightMax = height[R];\n      else res += rightMax - height[R];\n      R--;\n    }\n  }\n  return res;\n}"
    }
  }
]